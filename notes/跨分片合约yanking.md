
## Cross-shard contract yanking

这是跨分片锁定方案和类似技术的一般化，以实现跨分片来解决火车和酒店问题。从哲学上讲，“锁定”分片A上的合约实际上意味着冻结分片A上的状态，并将状态保存到收据中. 将合约导入分片B，在分片B上的某个对象之间执行某些操作，然后使用另一个收据将合约发送回分片A，然后该合约会继续存在与分片A。

我们可以通过将机制从“锁定”改为“yanking”来简化和概括这一点。我们向EVM添加操作码，YANK（一个堆栈参数：target_shard），它从状态中删除合约并产生一个包含合约状态和target_shard的收据;然后可以在target_shard中处理此收据，以在target_shard中实例化相同的合约。当合约被yank的时候,其可以自由地指定它们的条件。

例如，酒店预订合约可能通过具有预订酒店房间的函数reserve()来实现，实例化代表酒店房间的合约，然后该合约包含move_to_shard（uint256 shard_id）函数，该函数允许任何人将合约yank到另一个分片上。然后，人们可以通过预订酒店房间来解决火车和酒店问题，将酒店预定合约yank到火车预订合约相同的分片上，然后自动预订酒店房间和该分片上的火车票。如果需要，酒店房间合约的book（）功能可以自毁酒店房间合约，并签发一张收据，然后可以用来在酒店预订主合约中保存预订记录。如果用户在yanking之后但在atomically预订之前消失，那么任何想要预订酒店房间的人都可以使用相同的酒店房间合约来执行此操作，如果他们愿意，可能会让酒店房间合约回到原始分片。

为了提高效率，the yankee’s internal stat 必须很小，以便可以在收据中编码，并且the gas cost of yanking需要与the yankee’s total size 成比例。一般来说，从可用性的角度来看，对于许多用户可能感兴趣的合约来说，这是一个糟糕的想法，因为在合并到target_shard之前，yanking会使合约无法使用。出于这两个原因，最可能的工作流程是合约具有与上述酒店房间预定类似的行为，__其中合约将与个别交互相关的状态分离出来，以便可以分别在分片之间移动__。

注意，跨分片的消息和yanking之间存在很好的并行，现有的CALL和CREATE：CALL = 同步的分片内消息传递，CREATE = 同步的分片内合约创建，CROSS_SHARD_CALL = 异步跨分片消息传递，YANK = 异步跨分片合约创建。YANK操作码不一定需要删除现有合约并创建收据以在新分片上生成副本。这样做可能需要调用 CROSS_SHARD_CREATE 和 self-destruct ;虽然需要一个特性来允许在另一个分片中创建一个与原始分片具有相同地址的合同，但这将拥有完整的对称性。
